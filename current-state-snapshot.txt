
######################################################################
# KeyboardExtension/Dictionary/WordDictionary.swift
######################################################################

import Foundation

/// Loads and queries a bundled word list for swipe decoding.
class WordDictionary {

    private var words: Set<String> = []
    private var wordsByFirstLast: [String: [String]] = [:]  // "t-e" → ["the", "there", ...]
    private var frequencyIndex: [String: Int] = [:]         // word → rank (0 = most common)
    /// Frequency-ordered word list (first = most common)
    private(set) var wordList: [String] = []

    init() {
        loadWords()
    }

    private func loadWords() {
        guard let url = Bundle(for: type(of: self)).url(forResource: "words", withExtension: "txt"),
              let contents = try? String(contentsOf: url, encoding: .utf8) else {
            return
        }

        let allWords = contents.components(separatedBy: .newlines)
            .map { $0.trimmingCharacters(in: .whitespaces).lowercased() }
            .filter { !$0.isEmpty && $0.count >= 1 }

        wordList = allWords
        words = Set(allWords)

        // Build frequency index (position in file = rank)
        for (i, word) in allWords.enumerated() {
            if frequencyIndex[word] == nil {
                frequencyIndex[word] = i
            }
        }

        // Index by first-last letter pair for fast candidate lookup
        for word in allWords {
            guard let first = word.first, let last = word.last else { continue }
            let key = "\(first)-\(last)"
            wordsByFirstLast[key, default: []].append(word)
        }
    }

    func contains(_ word: String) -> Bool {
        words.contains(word.lowercased())
    }

    /// Find candidate words matching first letter, last letter, and approximate length.
    func candidates(startingWith first: Character,
                    endingWith last: Character,
                    lengthRange: ClosedRange<Int>) -> [String] {
        let key = "\(first.lowercased())-\(last.lowercased())"
        guard let pool = wordsByFirstLast[key] else { return [] }
        return pool.filter { lengthRange.contains($0.count) }
    }

    /// Return top N most frequent words, optionally excluding some.
    func predictNextWords(excluding: Set<String> = [], limit: Int = 3) -> [String] {
        var results: [String] = []
        for word in wordList {
            if !excluding.contains(word) {
                results.append(word)
                if results.count >= limit { break }
            }
        }
        return results
    }

    /// Return words matching a prefix, frequency-ordered.
    func wordsWithPrefix(_ prefix: String, limit: Int = 3) -> [String] {
        let p = prefix.lowercased()
        var results: [String] = []
        for word in wordList {
            if word.hasPrefix(p) {
                results.append(word)
                if results.count >= limit { break }
            }
        }
        return results
    }

    /// Return the frequency rank of a word (0 = most common). Returns wordList.count if not found.
    func frequencyRank(of word: String) -> Int {
        frequencyIndex[word.lowercased()] ?? wordList.count
    }
}

######################################################################
# KeyboardExtension/Input/ImmediateTouchGestureRecognizer.swift
######################################################################

import UIKit
import UIKit.UIGestureRecognizerSubclass

/// A gesture recognizer that transitions to .began on the very first touch,
/// in the same frame as the touch event — before any system gesture processing.
/// This is faster than UILongPressGestureRecognizer(minimumPressDuration: 0),
/// which waits one run loop cycle.
class ImmediateTouchGestureRecognizer: UIGestureRecognizer {

    override func touchesBegan(_ touches: Set<UITouch>, with event: UIEvent) {
        state = .began
    }

    override func touchesMoved(_ touches: Set<UITouch>, with event: UIEvent) {
        state = .changed
    }

    override func touchesEnded(_ touches: Set<UITouch>, with event: UIEvent) {
        state = .ended
    }

    override func touchesCancelled(_ touches: Set<UITouch>, with event: UIEvent) {
        state = .cancelled
    }

    override func reset() {
        super.reset()
    }
}

######################################################################
# KeyboardExtension/Input/SwipeDecoder.swift
######################################################################

import CoreGraphics

/// Matches a sequence of visited KeySlots to a dictionary word.
/// On a circular layout, swiping between keys inevitably passes through
/// intermediate keys. The decoder uses subsequence matching: a word matches
/// if its letters appear in order within the visited key sequence.
class SwipeDecoder {

    private let dictionary: WordDictionary

    // MARK: - Contractions

    /// Maps apostrophe-stripped forms to their contracted spelling.
    /// Only includes unambiguous cases (e.g. "were" is NOT "we're").
    private static let contractions: [String: String] = [
        "dont":     "don't",
        "doesnt":   "doesn't",
        "didnt":    "didn't",
        "wont":     "won't",
        "wouldnt":  "wouldn't",
        "shouldnt": "shouldn't",
        "couldnt":  "couldn't",
        "cant":     "can't",
        "isnt":     "isn't",
        "arent":    "aren't",
        "wasnt":    "wasn't",
        "werent":   "weren't",
        "hasnt":    "hasn't",
        "havent":   "haven't",
        "hadnt":    "hadn't",
        "mustnt":   "mustn't",
        "neednt":   "needn't",
        "youre":    "you're",
        "theyre":   "they're",
        "weve":     "we've",
        "youve":    "you've",
        "theyve":   "they've",
        "ive":      "I've",
        "youll":    "you'll",
        "theyll":   "they'll",
        "well":     "we'll",    // note: also a plain word — handled by score bonus
        "ill":      "I'll",     // same — "ill" is a word too
        "shell":    "she'll",   // same
        "hell":     "he'll",    // same
        "thats":    "that's",
        "whats":    "what's",
        "whos":     "who's",
        "heres":    "here's",
        "theres":   "there's",
        "lets":     "let's",
        "im":       "I'm",
        "youre":    "you're",
        "hes":      "he's",
        "shes":     "she's",
        "itll":     "it'll",
        "thatll":   "that'll",
        "wholl":    "who'll",
    ]

    /// Contractions that are also valid standalone words — only prefer
    /// the contraction if the score is significantly better.
    private static let ambiguousContractions: Set<String> = [
        "well", "ill", "shell", "hell", "lets", "hes", "shes",
    ]

    init(dictionary: WordDictionary) {
        self.dictionary = dictionary
    }

    /// Max slots to trim from the end to handle overshoot (e.g. "up" → "upg")
    private let maxTailTrim = 2

    func decode(visitedSlots: [KeySlot]) -> String? {
        guard !visitedSlots.isEmpty else { return nil }

        let visited = visitedSlots.map { $0.letter }

        // 1. Exact match (unlikely on circular layout, but fast check)
        let rawLetters = String(visited).lowercased()
        if dictionary.contains(rawLetters) {
            return rawLetters
        }

        let firstLetter = visited.first!

        var bestWord: String?
        var bestScore = CGFloat.infinity
        var bestContraction: String?
        var bestContractionScore = CGFloat.infinity

        // Try the full visited sequence, then trimmed versions (drop 1-2 from end)
        // to handle overshoot. Trimmed versions get a penalty per dropped slot.
        let trimLimit = min(maxTailTrim, visited.count - 1)

        for trim in 0...trimLimit {
            let trimmedVisited = Array(visited.prefix(visited.count - trim))
            let trimmedSlots = Array(visitedSlots.prefix(visitedSlots.count - trim))
            guard trimmedVisited.count >= 2 else { continue }

            let lastLetter = trimmedVisited.last!
            let trimPenalty = CGFloat(trim) * 6.0

            // 2. Subsequence matching against dictionary
            let candidates = dictionary.candidates(
                startingWith: firstLetter,
                endingWith: lastLetter,
                lengthRange: 2...trimmedVisited.count
            )

            for word in candidates {
                if let score = subsequenceScore(word: word, visited: trimmedVisited, slots: trimmedSlots) {
                    let freqPenalty = CGFloat(dictionary.frequencyRank(of: word)) * 0.02
                    let total = score + freqPenalty + trimPenalty
                    if total < bestScore {
                        bestScore = total
                        bestWord = word
                    }
                }
            }

            // 3. Check contractions
            for (stripped, contracted) in Self.contractions {
                let strippedChars = Array(stripped.uppercased())
                guard let firstChar = strippedChars.first,
                      let lastChar = strippedChars.last,
                      firstChar == firstLetter,
                      lastChar == lastLetter else { continue }

                if let score = subsequenceScore(word: stripped, visited: trimmedVisited, slots: trimmedSlots) {
                    let bonus: CGFloat = Self.ambiguousContractions.contains(stripped) ? 0 : -5.0
                    let total = score + bonus + trimPenalty
                    if total < bestContractionScore {
                        bestContractionScore = total
                        bestContraction = contracted
                    }
                }
            }
        }

        // Pick the best overall
        if let contraction = bestContraction, bestContractionScore < bestScore {
            return contraction
        }

        // Return dictionary match or nil (no gibberish fallback)
        return bestWord
    }

    /// Check if word's letters appear as a subsequence of visited keys.
    /// Returns a score (lower = better) or nil if not a subsequence.
    ///
    /// Score factors:
    /// - Tightness: fewer skipped keys between matched letters is better
    /// - Coverage: matched letters should span most of the visited sequence
    /// - Word length: longer words preferred (more intentional)
    /// - Frequency: common words preferred (applied in caller)
    private func subsequenceScore(word: String, visited: [Character],
                                  slots: [KeySlot]) -> CGFloat? {
        let wordChars = Array(word.uppercased())
        guard wordChars.count >= 2 else { return nil }

        // Collapse consecutive duplicate letters in the word for matching.
        // "sloppy" → "slopy" so we only need one P in the visited sequence.
        // We track which collapsed chars map to double letters for scoring.
        var collapsed: [Character] = []
        for ch in wordChars {
            if collapsed.last != ch {
                collapsed.append(ch)
            }
        }

        // Find the subsequence match with minimal total gaps
        var matchIndices: [Int] = []
        var searchFrom = 0

        for ch in collapsed {
            var found = false
            for i in searchFrom..<visited.count {
                if visited[i] == ch {
                    matchIndices.append(i)
                    searchFrom = i + 1
                    found = true
                    break
                }
            }
            if !found { return nil }  // Not a subsequence
        }

        // Score: lower is better

        // 1. Gap penalty: total number of unmatched visited keys between matched ones
        var totalGap = 0
        for i in 1..<matchIndices.count {
            totalGap += (matchIndices[i] - matchIndices[i - 1] - 1)
        }

        // 2. Span ratio: the match should cover a good portion of the visited sequence
        let span = matchIndices.last! - matchIndices.first! + 1
        let spanRatio = CGFloat(span) / CGFloat(visited.count)
        let spanPenalty = (1.0 - spanRatio) * 30.0

        // 3. Word length bonus: prefer longer words (more intentional)
        let lengthBonus = -CGFloat(wordChars.count) * 2.0

        return CGFloat(totalGap) * 3.0 + spanPenalty + lengthBonus
    }
}

######################################################################
# KeyboardExtension/Input/SwipeTracker.swift
######################################################################

import CoreGraphics

/// Tracks a swipe gesture across the ring, recording which keys are visited.
class SwipeTracker {

    private let slots: [KeySlot]
    private(set) var visitedSlots: [KeySlot] = []
    private(set) var currentSlot: KeySlot?

    private let proximityThreshold: CGFloat = RingView.swipeProximityThreshold

    /// Center of the ring in screen coordinates (set by caller)
    var ringCenter: CGPoint = .zero

    /// Track recent points for radial velocity detection
    private var recentPoints: [CGPoint] = []
    private let radialSampleCount = 3

    /// Minimum outward radial speed (pts per sample) to trigger suppression
    private let radialOutwardThreshold: CGFloat = 4.0

    /// Track movement direction angles for loop/circle detection (task #13)
    private var lastDirection: CGFloat?  // last absolute movement direction in degrees
    private var turnAccumulator: [CGFloat] = []  // recent signed turn deltas
    private let loopAngleThreshold: CGFloat = 300.0  // degrees of cumulative turn = circle
    private let loopWindowSize = 20

    init(slots: [KeySlot]) {
        self.slots = slots
    }

    func begin(at point: CGPoint, initialSlot: KeySlot?) {
        visitedSlots = []
        recentPoints = [point]
        lastDirection = nil
        turnAccumulator = []
        if let slot = initialSlot {
            visitedSlots.append(slot)
            currentSlot = slot
        } else {
            checkProximity(at: point)
        }
    }

    func addSample(_ point: CGPoint) {
        recentPoints.append(point)
        if recentPoints.count > radialSampleCount {
            recentPoints.removeFirst()
        }

        // Track angle changes for loop detection
        trackAngleChange(at: point)

        checkProximity(at: point)
    }

    func finalize() -> [KeySlot] {
        return visitedSlots
    }

    // MARK: - Radial velocity

    /// Returns positive if moving outward, negative if inward.
    private func radialVelocity() -> CGFloat {
        guard recentPoints.count >= 2 else { return 0 }
        let prev = recentPoints[recentPoints.count - 2]
        let curr = recentPoints[recentPoints.count - 1]
        let rPrev = GeometryHelpers.distanceFromCenter(prev, center: ringCenter)
        let rCurr = GeometryHelpers.distanceFromCenter(curr, center: ringCenter)
        return rCurr - rPrev
    }

    // MARK: - Loop detection for double letters

    private func trackAngleChange(at point: CGPoint) {
        guard recentPoints.count >= 2 else { return }
        let prev = recentPoints[recentPoints.count - 2]
        let curr = point

        let dx = curr.x - prev.x
        let dy = curr.y - prev.y
        guard dx * dx + dy * dy > 1.0 else { return }  // skip tiny movements

        let direction = atan2(dy, dx) * 180.0 / .pi

        if let last = lastDirection {
            var delta = direction - last
            // Normalize to -180..180
            while delta > 180 { delta -= 360 }
            while delta < -180 { delta += 360 }
            turnAccumulator.append(delta)

            // Keep window bounded
            if turnAccumulator.count > loopWindowSize {
                turnAccumulator.removeFirst()
            }
        }

        lastDirection = direction
    }

    /// Check if finger drew a loop recently (sum of angle deltas > threshold).
    private func detectLoop() -> Bool {
        guard turnAccumulator.count >= loopWindowSize / 2 else { return false }
        let totalTurn = turnAccumulator.suffix(loopWindowSize).reduce(0, +)
        if abs(totalTurn) >= loopAngleThreshold {
            turnAccumulator.removeAll()
            lastDirection = nil
            return true
        }
        return false
    }

    // MARK: - Proximity check

    private func checkProximity(at point: CGPoint) {
        guard let (nearest, dist) = GeometryHelpers.weightedNearestSlot(
            to: point, in: slots, maxDist: proximityThreshold),
              dist < proximityThreshold else {
            return
        }

        // Suppress inner ring keys when moving radially outward
        if nearest.ring == .inner && radialVelocity() > radialOutwardThreshold {
            return
        }

        // Check for loop → double letter
        if let last = visitedSlots.last, last.index == nearest.index {
            // Same key as last visited — check if we drew a loop (double letter)
            if detectLoop() {
                visitedSlots.append(nearest)
                currentSlot = nearest
            }
            return
        }

        // Don't add if it's the same as current (prevents duplicates from jitter)
        if let current = currentSlot, current.index == nearest.index {
            return
        }

        visitedSlots.append(nearest)
        currentSlot = nearest
    }
}

######################################################################
# KeyboardExtension/Input/TapHandler.swift
######################################################################

import Foundation

/// Handles single-letter tap insertion. Stateless utility.
enum TapHandler {
    // Intentionally empty — tap logic lives in TouchRouter → delegate callbacks.
    // This file exists as a namespace placeholder for future tap-related logic
    // (e.g., double-tap for caps, long-press for alternates).
}

######################################################################
# KeyboardExtension/Input/TouchRouter.swift
######################################################################

import UIKit

/// Classifies touches and routes them to the appropriate handler.
class TouchRouter {

    enum TouchMode {
        case none
        case centerHold       // center zone: dead space / long-hold cursor
        case centerCursor     // center zone after 2s hold: drag = cursor movement
        case keyTap(KeySlot)
        case ringSwipe
        case backspace
        case spaceZone        // right gap: tap = space, flick right = jump to end
    }

    private weak var ringView: RingView?
    private var mode: TouchMode = .none
    private var startPoint: CGPoint = .zero
    private var swipeTracker: SwipeTracker?

    // Center hold / cursor
    private var centerHoldTimer: Timer?
    private var cursorTimer: Timer?
    private var cursorOrigin: CGPoint = .zero
    private var cursorTouchPoint: CGPoint = .zero
    private var lastCursorPoint: CGPoint = .zero
    private var cursorAccumulator: CGFloat = 0
    private var cursorTimerAccumulator: CGFloat = 0

    /// Movement threshold to transition from tap to swipe
    private let swipeThreshold: CGFloat = 15.0
    /// How long to hold center before entering cursor mode
    private let centerHoldDuration: TimeInterval = 1.5
    /// Pixels of finger movement per cursor character step (trackpad style)
    private let cursorStepSize: CGFloat = 12.0
    /// Dead zone before continuous scrolling kicks in
    private let cursorDeadZone: CGFloat = 20.0
    /// Max cursor chars per second for continuous hold
    private let cursorMaxSpeed: CGFloat = 12.0
    /// Distance from origin for max speed
    private let cursorRampDistance: CGFloat = 80.0

    init(ringView: RingView) {
        self.ringView = ringView
    }

    // MARK: - Touch events

    func touchBegan(_ point: CGPoint) {
        guard let ringView = ringView else { return }
        startPoint = point

        let slots = ringView.slots
        let center = CGPoint(
            x: ringView.bounds.width / 2.0,
            y: ringView.bounds.height / 2.0
        )

        let distFromCenter = GeometryHelpers.distanceFromCenter(point, center: center)

        // Check center zone — dead space, long hold = cursor mode
        if distFromCenter < RingView.centerTapRadius {
            mode = .centerHold
            // Pre-arm swipe tracker so center-drag-to-swipe works
            swipeTracker = SwipeTracker(slots: slots)
            swipeTracker?.ringCenter = center
            swipeTracker?.begin(at: point, initialSlot: nil)
            // Start hold timer for cursor mode
            centerHoldTimer?.invalidate()
            centerHoldTimer = Timer.scheduledTimer(withTimeInterval: centerHoldDuration, repeats: false) { [weak self] _ in
                self?.activateCursorMode()
            }
            // Show glow building up
            ringView.showCenterHoldGlow()
            return
        }

        // Check gap zones — only in the outer ring radial range
        let angle = GeometryHelpers.angleDeg(from: center, to: point)
        let computedScale = ringView.bounds.height > 0
            ? (min(ringView.bounds.width, ringView.bounds.height) / 2.0 - 20.0)
              / (RingLayoutConfig.outerWedgeRMax + 0.1)
            : 1.0
        let outerRingMinR = RingLayoutConfig.outerWedgeRMin * computedScale

        // Only trigger gap zones when touch is in outer ring area
        if distFromCenter >= outerRingMinR {
            // Backspace zone (left gap around 180°)
            if GeometryHelpers.angleInGap(angle,
                                           gapCenter: RingLayoutConfig.leftGapAngle,
                                           gapWidth: RingLayoutConfig.gapWidthDeg) {
                mode = .backspace
                return
            }

            // Space zone (right gap around 0°) — tap=space
            if GeometryHelpers.angleInGap(angle,
                                           gapCenter: RingLayoutConfig.rightGapAngle,
                                           gapWidth: RingLayoutConfig.gapWidthDeg) {
                mode = .spaceZone
                return
            }
        }

        // Check nearest key (frequency-weighted, generous tap threshold)
        if let (nearest, dist) = GeometryHelpers.weightedNearestSlot(
            to: point, in: slots, maxDist: RingView.tapProximityThreshold),
           dist < RingView.tapProximityThreshold {
            mode = .keyTap(nearest)
            ringView.highlightKey(at: nearest.index)

            // Start swipe tracker in case this becomes a swipe
            swipeTracker = SwipeTracker(slots: slots)
            swipeTracker?.ringCenter = center
            swipeTracker?.begin(at: point, initialSlot: nearest)
            ringView.swipeTrail.beginTrail(at: point)
            return
        }

        // Anywhere else — start as potential swipe
        swipeTracker = SwipeTracker(slots: slots)
        swipeTracker?.ringCenter = center
        swipeTracker?.begin(at: point, initialSlot: nil)
        ringView.swipeTrail.beginTrail(at: point)
        mode = .ringSwipe
    }

    func touchMoved(_ point: CGPoint) {
        guard let ringView = ringView else { return }

        switch mode {
        case .centerHold:
            let moved = GeometryHelpers.distance(startPoint, point)
            if moved > swipeThreshold {
                // Cancel hold timer, transition to swipe
                centerHoldTimer?.invalidate()
                centerHoldTimer = nil
                ringView.hideCenterGlow()
                mode = .ringSwipe
                ringView.swipeTrail.beginTrail(at: startPoint)
                if let tracker = swipeTracker {
                    tracker.addSample(point)
                    ringView.swipeTrail.addPoint(point)
                }
            }

        case .centerCursor:
            // Displacement-based: immediate response to finger movement
            let dx = point.x - lastCursorPoint.x
            cursorAccumulator += dx
            lastCursorPoint = point
            cursorTouchPoint = point

            while cursorAccumulator > cursorStepSize {
                cursorAccumulator -= cursorStepSize
                ringView.delegate?.ringView(ringView, didMoveCursorRight: ())
            }
            while cursorAccumulator < -cursorStepSize {
                cursorAccumulator += cursorStepSize
                ringView.delegate?.ringView(ringView, didMoveCursorLeft: ())
            }

        case .keyTap:
            let moved = GeometryHelpers.distance(startPoint, point)
            if moved > swipeThreshold {
                mode = .ringSwipe
                ringView.unhighlightAllKeys()
            }
            if let tracker = swipeTracker {
                tracker.addSample(point)
                ringView.swipeTrail.addPoint(point)
                ringView.unhighlightAllKeys()
                if let current = tracker.currentSlot {
                    ringView.highlightKey(at: current.index)
                }
            }

        case .ringSwipe:
            if let tracker = swipeTracker {
                tracker.addSample(point)
                ringView.swipeTrail.addPoint(point)
                ringView.unhighlightAllKeys()
                if let current = tracker.currentSlot {
                    ringView.highlightKey(at: current.index)
                }
            }

        default:
            break
        }
    }

    func touchEnded(_ point: CGPoint) {
        guard let ringView = ringView else { return }

        defer {
            cleanup()
        }

        switch mode {
        case .centerHold:
            // Dead space — no action on short tap/release
            break

        case .centerCursor:
            break // Just stop cursor movement

        case .keyTap(let slot):
            let moved = GeometryHelpers.distance(startPoint, point)
            if moved <= swipeThreshold {
                ringView.delegate?.ringView(ringView, didTapLetter: slot.letter)
            } else {
                finalizeSwipe()
            }

        case .ringSwipe:
            if let tracker = swipeTracker {
                let visitedSlots = tracker.finalize()
                if !visitedSlots.isEmpty {
                    ringView.delegate?.ringView(ringView, didSwipeWord: visitedSlots)
                } else {
                    // No keys visited — check for center-to-gap directional swipe
                    let center = CGPoint(x: ringView.bounds.width / 2.0,
                                         y: ringView.bounds.height / 2.0)
                    let startedFromCenter = GeometryHelpers.distanceFromCenter(
                        startPoint, center: center) < RingView.centerTapRadius
                    let moved = GeometryHelpers.distance(startPoint, point)
                    if startedFromCenter && moved > swipeThreshold {
                        if point.x < startPoint.x {
                            ringView.delegate?.ringView(ringView, didDeleteWord: ())
                        } else if point.x > startPoint.x {
                            ringView.delegate?.ringView(ringView, didJumpToEnd: ())
                        }
                    }
                }
            }

        case .backspace:
            let moved = GeometryHelpers.distance(startPoint, point)
            let swipedLeft = point.x < startPoint.x
            if moved > swipeThreshold && swipedLeft {
                ringView.delegate?.ringView(ringView, didDeleteWord: ())
            } else if moved <= swipeThreshold {
                ringView.delegate?.ringView(ringView, didTapBackspace: ())
            }

        case .spaceZone:
            let moved = GeometryHelpers.distance(startPoint, point)
            let swipedRight = point.x > startPoint.x
            if moved > swipeThreshold && swipedRight {
                ringView.delegate?.ringView(ringView, didJumpToEnd: ())
            } else if moved <= swipeThreshold {
                ringView.delegate?.ringView(ringView, didTapSpace: ())
            }

        case .none:
            break
        }
    }

    func touchCancelled() {
        cleanup()
    }

    // MARK: - Cursor mode

    private func activateCursorMode() {
        guard let ringView = ringView else { return }
        mode = .centerCursor
        cursorOrigin = startPoint
        cursorTouchPoint = startPoint
        lastCursorPoint = startPoint
        cursorAccumulator = 0
        cursorTimerAccumulator = 0
        swipeTracker = nil
        ringView.showCenterCursorActive()

        // Timer for continuous scrolling when finger is held away from origin
        cursorTimer = Timer.scheduledTimer(withTimeInterval: 0.05, repeats: true) { [weak self] _ in
            self?.fireCursorTick()
        }
    }

    /// Continuous scrolling: moves cursor when finger is held away from origin.
    private func fireCursorTick() {
        guard let ringView = ringView else { return }
        let dx = cursorTouchPoint.x - cursorOrigin.x
        let distance = abs(dx)
        guard distance > cursorDeadZone else {
            cursorTimerAccumulator = 0
            return
        }

        let t = min((distance - cursorDeadZone) / cursorRampDistance, 1.0)
        let speed = t * cursorMaxSpeed
        cursorTimerAccumulator += speed * 0.05
        let steps = Int(cursorTimerAccumulator)
        if steps > 0 {
            cursorTimerAccumulator -= CGFloat(steps)
            if dx > 0 {
                for _ in 0..<steps {
                    ringView.delegate?.ringView(ringView, didMoveCursorRight: ())
                }
            } else {
                for _ in 0..<steps {
                    ringView.delegate?.ringView(ringView, didMoveCursorLeft: ())
                }
            }
        }
    }

    // MARK: - Private

    private func finalizeSwipe() {
        guard let ringView = ringView,
              let tracker = swipeTracker else { return }
        let visitedSlots = tracker.finalize()
        if !visitedSlots.isEmpty {
            ringView.delegate?.ringView(ringView, didSwipeWord: visitedSlots)
        }
    }

    private func cleanup() {
        centerHoldTimer?.invalidate()
        centerHoldTimer = nil
        cursorTimer?.invalidate()
        cursorTimer = nil
        ringView?.hideCenterGlow()
        ringView?.unhighlightAllKeys()
        ringView?.swipeTrail.clearTrail()
        swipeTracker = nil
        mode = .none
    }
}

######################################################################
# KeyboardExtension/KeyboardViewController.swift
######################################################################

import UIKit

class KeyboardViewController: UIInputViewController {

    private var ringView: RingView!
    private var wordDictionary: WordDictionary!
    private var swipeDecoder: SwipeDecoder!
    private var isShifted = false


    // MARK: - Lifecycle

    override func viewDidLoad() {
        super.viewDidLoad()

        wordDictionary = WordDictionary()
        swipeDecoder = SwipeDecoder(dictionary: wordDictionary)

        ringView = RingView(frame: .zero)
        ringView.delegate = self
        ringView.translatesAutoresizingMaskIntoConstraints = false
        view.addSubview(ringView)

        NSLayoutConstraint.activate([
            ringView.leadingAnchor.constraint(equalTo: view.leadingAnchor),
            ringView.trailingAnchor.constraint(equalTo: view.trailingAnchor),
            ringView.topAnchor.constraint(equalTo: view.topAnchor),
            ringView.bottomAnchor.constraint(equalTo: view.bottomAnchor),
        ])

        let heightConstraint = view.heightAnchor.constraint(equalToConstant: 290)
        heightConstraint.priority = .defaultHigh
        heightConstraint.isActive = true
    }

    override func viewWillLayoutSubviews() {
        super.viewWillLayoutSubviews()
        ringView.configure(viewSize: view.bounds.size)
        disableConflictingSystemGestures()
    }

    override func viewDidAppear(_ animated: Bool) {
        super.viewDidAppear(animated)
        disableConflictingSystemGestures()
        checkAutoShift()
    }

    /// Remove ALL system gesture recognizers on ancestor views that
    /// could conflict with our raw touch handling (keyboard-switch gestures, etc.)
    private func disableConflictingSystemGestures() {
        var current: UIView? = view
        while let v = current {
            if let recognizers = v.gestureRecognizers {
                for gesture in recognizers {
                    v.removeGestureRecognizer(gesture)
                }
            }
            current = v.superview
        }
    }

    // MARK: - Auto-capitalize

    /// Auto-capitalize standalone "i" → "I" after inserting a space.
    private func autoCorrectStandaloneI() {
        guard let before = textDocumentProxy.documentContextBeforeInput else { return }
        // Check for " i " pattern (space + i + space we just inserted)
        if before.hasSuffix(" i ") {
            // Delete " i " (3 chars), reinsert as " I "
            for _ in 0..<3 { textDocumentProxy.deleteBackward() }
            textDocumentProxy.insertText(" I ")
        } else if before == "i " && before.count == 2 {
            // "i" at very start of input
            for _ in 0..<2 { textDocumentProxy.deleteBackward() }
            textDocumentProxy.insertText("I ")
        }
    }

    /// Enable auto-shift at sentence boundaries.
    private func checkAutoShift() {
        guard !isShifted else { return }
        let before = textDocumentProxy.documentContextBeforeInput ?? ""
        let shouldShift = before.isEmpty
            || before.hasSuffix(". ")
            || before.hasSuffix("! ")
            || before.hasSuffix("? ")
            || before.hasSuffix("\n")
        if shouldShift {
            isShifted = true
            ringView.updateShiftAppearance(isShifted: true)
        }
    }

}

// MARK: - RingViewDelegate

extension KeyboardViewController: RingViewDelegate {

    func ringView(_ ringView: RingView, didTapLetter letter: Character) {
        var text = String(letter)
        if isShifted {
            text = text.uppercased()
            isShifted = false
            ringView.updateShiftAppearance(isShifted: false)
        } else {
            text = text.lowercased()
        }
        textDocumentProxy.insertText(text)

        checkAutoShift()
    }

    func ringView(_ ringView: RingView, didTapSpace: Void) {
        let before = textDocumentProxy.documentContextBeforeInput ?? ""
        if before.hasSuffix(" ") && !before.hasSuffix(". ") && !before.isEmpty {
            // Double space → period
            textDocumentProxy.deleteBackward()
            textDocumentProxy.insertText(". ")
        } else {
            textDocumentProxy.insertText(" ")
            autoCorrectStandaloneI()
        }

        checkAutoShift()
    }

    func ringView(_ ringView: RingView, didTapBackspace: Void) {
        textDocumentProxy.deleteBackward()

        checkAutoShift()
    }

    func ringView(_ ringView: RingView, didSwipeWord slots: [KeySlot]) {
        guard let word = swipeDecoder.decode(visitedSlots: slots) else { return }
        var text = word
        if isShifted {
            text = text.prefix(1).uppercased() + text.dropFirst()
            isShifted = false
            ringView.updateShiftAppearance(isShifted: false)
        }
        let before = textDocumentProxy.documentContextBeforeInput ?? ""
        let prefix = (!before.isEmpty && !before.hasSuffix(" ")) ? " " : ""
        let afterInput = textDocumentProxy.documentContextAfterInput ?? ""
        let suffix = afterInput.hasPrefix(" ") ? "" : " "
        textDocumentProxy.insertText(prefix + text + suffix)

        checkAutoShift()
    }

    func ringView(_ ringView: RingView, didTapShift: Void) {
        isShifted.toggle()
        ringView.updateShiftAppearance(isShifted: isShifted)
    }

    func ringView(_ ringView: RingView, didTapReturn: Void) {
        textDocumentProxy.insertText("\n")

        checkAutoShift()
    }

    func ringView(_ ringView: RingView, didMoveCursorLeft: Void) {
        textDocumentProxy.adjustTextPosition(byCharacterOffset: -1)

    }

    func ringView(_ ringView: RingView, didMoveCursorRight: Void) {
        textDocumentProxy.adjustTextPosition(byCharacterOffset: 1)

    }

    func ringView(_ ringView: RingView, didDeleteWord: Void) {
        // Delete backward until we hit a space or run out of text
        // First skip any trailing spaces
        while let before = textDocumentProxy.documentContextBeforeInput,
              before.hasSuffix(" ") {
            textDocumentProxy.deleteBackward()
        }
        // Then delete the word itself
        while let before = textDocumentProxy.documentContextBeforeInput,
              !before.isEmpty,
              !before.hasSuffix(" ") {
            textDocumentProxy.deleteBackward()
        }

        checkAutoShift()
    }

    func ringView(_ ringView: RingView, didJumpToEnd: Void) {
        // Jump cursor to the end of all text
        let after = textDocumentProxy.documentContextAfterInput ?? ""
        if !after.isEmpty {
            textDocumentProxy.adjustTextPosition(byCharacterOffset: after.count)
        }

    }

    func ringView(_ ringView: RingView, didTapPunctuation character: Character) {
        // Smart punctuation: remove trailing space before sentence punctuation
        let before = textDocumentProxy.documentContextBeforeInput ?? ""
        if ".?!,".contains(character) && before.hasSuffix(" ") && !before.isEmpty {
            textDocumentProxy.deleteBackward()
        }
        textDocumentProxy.insertText(String(character))

        checkAutoShift()
    }

}

######################################################################
# KeyboardExtension/Layout/KeySlot.swift
######################################################################

import CoreGraphics

enum Ring: String {
    case inner
    case outer
}

struct KeySlot {
    let letter: Character
    let ring: Ring
    let index: Int
    /// Angle in degrees (0 = right, CCW positive, math convention)
    let angleDeg: CGFloat
    /// Normalized position from optimizer (unit-circle scale)
    let normalizedPosition: CGPoint
    /// Angular width of this key's wedge in degrees
    var angularWidthDeg: CGFloat = 0
    /// Screen position (computed at layout time)
    var screenPosition: CGPoint = .zero

    var letterString: String { String(letter) }
}

######################################################################
# KeyboardExtension/Layout/RingLayoutConfig.swift
######################################################################

import CoreGraphics

/// Hardcoded layout from optimizer output.
/// Positions are in normalized coordinates (inner ring radius = 1.0, outer = 2.2).
/// Screen positions are computed at layout time by applying center + scale.
enum RingLayoutConfig {

    // MARK: - Ring geometry

    static let innerRadius: CGFloat = 1.0
    static let outerRadius: CGFloat = 2.2

    /// Gap centers in degrees (math convention: 0=right, CCW positive)
    static let leftGapAngle: CGFloat = 180.0   // backspace
    static let rightGapAngle: CGFloat = 0.0     // reserved
    static let gapWidthDeg: CGFloat = 36.0
    static let usableArcDeg: CGFloat = 288.0
    static let arcStartDeg: CGFloat = 18.0      // right after right gap
    static let arcEndDeg: CGFloat = 162.0        // just before left gap

    // MARK: - Wedge geometry

    static let innerKeyAngularWidth: CGFloat = 288.0 / 8.0   // 36°
    static let outerKeyAngularWidth: CGFloat = 288.0 / 18.0   // 16°

    static let innerWedgeRMin: CGFloat = innerRadius * 0.6                    // 0.6
    static let innerWedgeRMax: CGFloat = (innerRadius + outerRadius) / 2.0    // 1.6
    static let outerWedgeRMin: CGFloat = (innerRadius + outerRadius) / 2.0    // 1.6
    static let outerWedgeRMax: CGFloat = outerRadius + 0.15                   // 2.35

    // Arc button radius (punctuation + function buttons along outer ring curve)
    static let buttonArcRadius: CGFloat = outerWedgeRMax + 0.80              // 3.15

    // MARK: - Key slots (from optimizer run)

    static func makeSlots() -> [KeySlot] {
        let data: [(Character, Ring, Int, CGFloat, CGFloat, CGFloat)] = [
            // Inner ring (8 slots) — all top-8 frequency letters
            ("H", .inner, 0,  36.0,  0.809,   0.5878),
            ("N", .inner, 1,  72.0,  0.309,   0.9511),
            ("S", .inner, 2, 108.0, -0.309,   0.9511),
            ("T", .inner, 3, 144.0, -0.809,   0.5878),
            ("E", .inner, 4, 216.0, -0.809,  -0.5878),
            ("A", .inner, 5, 252.0, -0.309,  -0.9511),
            ("I", .inner, 6, 288.0,  0.309,  -0.9511),
            ("O", .inner, 7, 324.0,  0.809,  -0.5878),
            // Outer ring (18 slots) — rare letters toward bottom-right
            ("B", .outer,  8,  26.0,  1.9773,  0.9644),
            ("V", .outer,  9,  42.0,  1.6349,  1.4721),
            ("M", .outer, 10,  58.0,  1.1658,  1.8657),
            ("R", .outer, 11,  74.0,  0.6064,  2.1148),
            ("L", .outer, 12,  90.0,  0.0,     2.2),
            ("W", .outer, 13, 106.0, -0.6064,  2.1148),
            ("C", .outer, 14, 122.0, -1.1658,  1.8657),
            ("D", .outer, 15, 138.0, -1.6349,  1.4721),
            ("F", .outer, 16, 154.0, -1.9773,  0.9644),
            // — left gap (162°–198°) —
            ("G", .outer, 17, 206.0, -1.9773, -0.9644),
            ("P", .outer, 18, 222.0, -1.6349, -1.4721),
            ("U", .outer, 19, 238.0, -1.1658, -1.8657),
            ("Y", .outer, 20, 254.0, -0.6064, -2.1148),
            ("K", .outer, 21, 270.0,  0.0,    -2.2),
            ("J", .outer, 22, 286.0,  0.6064, -2.1148),
            ("Q", .outer, 23, 302.0,  1.1658, -1.8657),
            ("Z", .outer, 24, 318.0,  1.6349, -1.4721),
            ("X", .outer, 25, 334.0,  1.9773, -0.9644),
        ]
        return data.map { letter, ring, idx, angle, x, y in
            var slot = KeySlot(letter: letter, ring: ring, index: idx,
                               angleDeg: angle,
                               normalizedPosition: CGPoint(x: x, y: y))
            slot.angularWidthDeg = (ring == .inner) ? innerKeyAngularWidth : outerKeyAngularWidth
            return slot
        }
    }

    // MARK: - Symbol/number slots (10 inner digits + 18 outer symbols)

    static func makeSymbolSlots() -> [KeySlot] {
        // Inner ring: 10 digits across full 360° (fills gap angles at 0° and 180°)
        let innerData: [(Character, CGFloat, CGFloat, CGFloat)] = [
            ("1",  36.0,  0.809,   0.5878),
            ("2",  72.0,  0.309,   0.9511),
            ("3", 108.0, -0.309,   0.9511),
            ("4", 144.0, -0.809,   0.5878),
            ("5", 180.0, -1.0,     0.0),
            ("6", 216.0, -0.809,  -0.5878),
            ("7", 252.0, -0.309,  -0.9511),
            ("8", 288.0,  0.309,  -0.9511),
            ("9", 324.0,  0.809,  -0.5878),
            ("0",   0.0,  1.0,     0.0),
        ]

        var slots: [KeySlot] = []
        for (i, (char, angle, x, y)) in innerData.enumerated() {
            var slot = KeySlot(letter: char, ring: .inner, index: i,
                               angleDeg: angle,
                               normalizedPosition: CGPoint(x: x, y: y))
            slot.angularWidthDeg = 36.0
            slots.append(slot)
        }

        // Outer ring: 18 symbols at same angular positions as letter layout
        let outerSymbols: [Character] = [".", ",", "!", "?", "'", "-", "@", "#",
                                          "(", ")", "+", "=", "/", ":", ";", "\"",
                                          "&", "*"]
        let letterSlots = makeSlots().filter { $0.ring == .outer }
        for (i, ls) in letterSlots.enumerated() {
            var slot = KeySlot(letter: outerSymbols[i], ring: .outer,
                               index: innerData.count + i,
                               angleDeg: ls.angleDeg,
                               normalizedPosition: ls.normalizedPosition,
                               angularWidthDeg: ls.angularWidthDeg)
            slots.append(slot)
        }

        return slots
    }

    // MARK: - Screen coordinate conversion

    /// Compute scale factor and center for a given keyboard view size.
    /// The outer ring edge should fit within the view with some padding.
    static func computeLayout(viewSize: CGSize) -> (center: CGPoint, scale: CGFloat) {
        let center = CGPoint(x: viewSize.width / 2.0, y: viewSize.height / 2.0)
        // Scale to fit the main two rings; arc buttons sit just outside
        let availableRadius = min(viewSize.width, viewSize.height) / 2.0 - 20.0
        let scale = availableRadius / (outerWedgeRMax + 0.1)
        return (center, scale)
    }

    /// Apply center and scale to convert normalized positions to screen coordinates.
    /// Note: y is flipped because iOS y-axis points down.
    static func applyScreenPositions(slots: inout [KeySlot], center: CGPoint, scale: CGFloat) {
        for i in slots.indices {
            let norm = slots[i].normalizedPosition
            slots[i].screenPosition = CGPoint(
                x: center.x + norm.x * scale,
                y: center.y - norm.y * scale  // flip y for iOS
            )
        }
    }
}

######################################################################
# KeyboardExtension/Rendering/KeyCapLayer.swift
######################################################################

import UIKit
import QuartzCore

/// A single key on the ring: bracket-shaped outline + radially-oriented letter.
class KeyCapLayer: CAShapeLayer {

    let slot: KeySlot
    private let textLayer = CATextLayer()

    // LED glow theme
    static let glowColor = SwipeTrailLayer.glowColor
    static let bracketColor = UIColor(white: 0.35, alpha: 1.0).cgColor
    static let textColor = UIColor.white.cgColor
    static let highlightTextColor = SwipeTrailLayer.glowColor.cgColor

    init(slot: KeySlot) {
        self.slot = slot
        super.init()
        setupLayers()
    }

    required init?(coder: NSCoder) { fatalError() }

    override init(layer: Any) {
        if let other = layer as? KeyCapLayer {
            self.slot = other.slot
        } else {
            self.slot = KeySlot(letter: "?", ring: .inner, index: 0,
                                angleDeg: 0, normalizedPosition: .zero,
                                angularWidthDeg: 0)
        }
        super.init(layer: layer)
    }

    private func setupLayers() {
        fillColor = nil  // transparent — bracket outline only
        strokeColor = Self.bracketColor
        lineWidth = 1.0
        lineCap = .round

        // No glow by default
        shadowColor = Self.glowColor.cgColor
        shadowRadius = 0
        shadowOpacity = 0
        shadowOffset = .zero

        textLayer.string = slot.letterString
        switch slot.ring {
        case .inner: textLayer.fontSize = 16
        case .outer: textLayer.fontSize = 13
        }
        textLayer.alignmentMode = .center
        textLayer.foregroundColor = Self.textColor
        textLayer.contentsScale = UIScreen.main.scale
        textLayer.isWrapped = false
        addSublayer(textLayer)
    }

    /// Draw the key as two bracket marks at the angular edges of the key's wedge.
    func updateWedge(center: CGPoint, scale: CGFloat) {
        let halfAngle = (slot.angularWidthDeg / 2.0) - 1.0  // 1° inset gap
        guard halfAngle > 0 else { return }

        let startDeg = slot.angleDeg - halfAngle
        let endDeg = slot.angleDeg + halfAngle

        // Bracket radii: inner and outer keys meet at the midpoint (no gap)
        let rMin: CGFloat
        let rMax: CGFloat
        switch slot.ring {
        case .inner:
            rMin = RingLayoutConfig.innerWedgeRMin * scale
            rMax = RingLayoutConfig.innerWedgeRMax * scale
        case .outer:
            rMin = RingLayoutConfig.outerWedgeRMin * scale
            rMax = RingLayoutConfig.outerWedgeRMax * scale
        }

        // Bracket arm: 30% of the usable half-angle on each side
        let armDeg = halfAngle * 0.55

        let bracketPath = UIBezierPath()

        // Left bracket (at startDeg side)
        drawBracket(into: bracketPath, center: center,
                    edgeDeg: startDeg, armDeg: armDeg,
                    rMin: rMin, rMax: rMax, openToward: 1.0)

        // Right bracket (at endDeg side)
        drawBracket(into: bracketPath, center: center,
                    edgeDeg: endDeg, armDeg: armDeg,
                    rMin: rMin, rMax: rMax, openToward: -1.0)

        path = bracketPath.cgPath

        // Position text at radial center of bracket (not ring radius)
        let midR = (rMin + rMax) / 2.0
        let angleRad = -slot.angleDeg * .pi / 180.0
        let pos = CGPoint(x: center.x + midR * cos(angleRad),
                          y: center.y + midR * sin(angleRad))
        let textW: CGFloat = 36
        let textH: CGFloat = 20
        textLayer.bounds = CGRect(origin: .zero, size: CGSize(width: textW, height: textH))
        textLayer.position = pos

        // Radial rotation: always upright, flipped at equator.
        // Top half (0°–180°): bottom of letter faces center → top faces up/outward
        // Bottom half (180°–360°): top of letter faces center → top faces up
        let isTopHalf = slot.angleDeg > 0 && slot.angleDeg < 180
        let rotationDeg = isTopHalf ? (90.0 - slot.angleDeg) : (270.0 - slot.angleDeg)
        textLayer.transform = CATransform3DMakeRotation(rotationDeg * .pi / 180.0, 0, 0, 1)
    }

    /// Draw one bracket arm (like `[` or `]`) as a single connected stroke:
    /// outer arc tip → radial edge → inner arc tip.
    private func drawBracket(into path: UIBezierPath, center: CGPoint,
                             edgeDeg: CGFloat, armDeg: CGFloat,
                             rMin: CGFloat, rMax: CGFloat,
                             openToward: CGFloat) {
        let edgeRad = -edgeDeg * .pi / 180.0
        let armEndDeg = edgeDeg + armDeg * openToward
        let armEndRad = -armEndDeg * .pi / 180.0

        // Start at outer arc tip (the far end of the arm)
        path.move(to: CGPoint(x: center.x + rMax * cos(armEndRad),
                               y: center.y + rMax * sin(armEndRad)))

        // Arc along outer radius back to the edge (short arc)
        path.addArc(withCenter: center, radius: rMax,
                    startAngle: armEndRad, endAngle: edgeRad,
                    clockwise: openToward > 0)

        // Radial line down to inner radius
        path.addLine(to: CGPoint(x: center.x + rMin * cos(edgeRad),
                                  y: center.y + rMin * sin(edgeRad)))

        // Arc along inner radius to inner arc tip (short arc)
        path.addArc(withCenter: center, radius: rMin,
                    startAngle: edgeRad, endAngle: armEndRad,
                    clockwise: openToward < 0)
    }

    func setHighlighted(_ highlighted: Bool) {
        if highlighted {
            strokeColor = Self.glowColor.cgColor
            textLayer.foregroundColor = Self.highlightTextColor
            shadowRadius = 10
            shadowOpacity = 0.9

            // Pulse animation
            let pulse = CAKeyframeAnimation(keyPath: "transform.scale")
            pulse.values = [1.0, 1.25, 1.0]
            pulse.keyTimes = [0, 0.3, 1.0]
            pulse.duration = 0.3
            pulse.isRemovedOnCompletion = true
            textLayer.add(pulse, forKey: "pulse")
        } else {
            strokeColor = Self.bracketColor
            textLayer.foregroundColor = Self.textColor
            shadowRadius = 0
            shadowOpacity = 0
        }
    }

    func refreshColors() {
        // For dark/light mode changes — in LED mode, mostly static
        if shadowOpacity == 0 {
            strokeColor = Self.bracketColor
            textLayer.foregroundColor = Self.textColor
        }
    }
}

######################################################################
# KeyboardExtension/Rendering/RingView.swift
######################################################################

import UIKit

protocol RingViewDelegate: AnyObject {
    func ringView(_ ringView: RingView, didTapLetter letter: Character)
    func ringView(_ ringView: RingView, didTapSpace: Void)
    func ringView(_ ringView: RingView, didTapBackspace: Void)
    func ringView(_ ringView: RingView, didSwipeWord slots: [KeySlot])
    func ringView(_ ringView: RingView, didTapShift: Void)
    func ringView(_ ringView: RingView, didTapReturn: Void)
    func ringView(_ ringView: RingView, didMoveCursorLeft: Void)
    func ringView(_ ringView: RingView, didMoveCursorRight: Void)
    func ringView(_ ringView: RingView, didDeleteWord: Void)
    func ringView(_ ringView: RingView, didJumpToEnd: Void)
    func ringView(_ ringView: RingView, didTapPunctuation character: Character)
}

class RingView: UIView {

    weak var delegate: RingViewDelegate?

    // MARK: - Layout state

    private(set) var slots: [KeySlot] = []
    private var letterSlots: [KeySlot] = []
    private var symbolSlots: [KeySlot] = []
    private(set) var isSymbolMode = false
    private var center_: CGPoint = .zero
    private var scale: CGFloat = 1.0

    // MARK: - Layers

    private let innerRingArc = CAShapeLayer()
    private let outerRingArc = CAShapeLayer()
    private let backspaceZone = CAShapeLayer()
    private let spaceZone = CAShapeLayer()
    private let centerZone = CAShapeLayer()
    private let backspaceLabel = CATextLayer()
    private let spaceLabel = CATextLayer()
    private var keyCapLayers: [KeyCapLayer] = []
    let swipeTrail = SwipeTrailLayer()

    // MARK: - Arc buttons (punctuation left, function right)

    private var punctuationButtons: [UIButton] = []
    private var functionButtons: [UIButton] = []

    // MARK: - Theme colors

    private static let bgColor = UIColor.black
    private static let dimColor = UIColor(white: 0.15, alpha: 1.0)
    private static let subtleStroke = UIColor(white: 0.25, alpha: 1.0)
    private static let labelColor = UIColor(white: 0.5, alpha: 1.0)
    private static let glowColor = SwipeTrailLayer.glowColor

    // MARK: - Input handling

    private lazy var touchRouter = TouchRouter(ringView: self)

    // MARK: - Constants

    static let centerTapRadius: CGFloat = 30.0
    static let tapProximityThreshold: CGFloat = 44.0
    static let swipeProximityThreshold: CGFloat = 26.0

    // MARK: - Init

    override init(frame: CGRect) {
        super.init(frame: frame)
        backgroundColor = Self.bgColor
        setupLayers()
        setupArcButtons()
    }

    required init?(coder: NSCoder) { fatalError() }

    // MARK: - Configuration

    func configure(viewSize: CGSize) {
        let layout = RingLayoutConfig.computeLayout(viewSize: viewSize)
        center_ = layout.center
        scale = layout.scale

        letterSlots = RingLayoutConfig.makeSlots()
        RingLayoutConfig.applyScreenPositions(slots: &letterSlots, center: center_, scale: scale)

        symbolSlots = RingLayoutConfig.makeSymbolSlots()
        RingLayoutConfig.applyScreenPositions(slots: &symbolSlots, center: center_, scale: scale)

        slots = isSymbolMode ? symbolSlots : letterSlots
        rebuildLayers()
    }

    // MARK: - Dark mode

    override func traitCollectionDidChange(_ previousTraitCollection: UITraitCollection?) {
        super.traitCollectionDidChange(previousTraitCollection)
        if traitCollection.hasDifferentColorAppearance(comparedTo: previousTraitCollection) {
            refreshAllColors()
        }
    }

    private func refreshAllColors() {
        innerRingArc.strokeColor = Self.subtleStroke.cgColor
        outerRingArc.strokeColor = Self.subtleStroke.cgColor
        backspaceZone.fillColor = UIColor.systemRed.withAlphaComponent(0.08).cgColor
        backspaceZone.strokeColor = Self.subtleStroke.withAlphaComponent(0.3).cgColor
        spaceZone.fillColor = Self.glowColor.withAlphaComponent(0.04).cgColor
        spaceZone.strokeColor = Self.subtleStroke.withAlphaComponent(0.3).cgColor
        backspaceLabel.foregroundColor = Self.labelColor.cgColor
        spaceLabel.foregroundColor = Self.labelColor.cgColor
        centerZone.fillColor = Self.dimColor.cgColor
        centerZone.strokeColor = Self.subtleStroke.cgColor
        keyCapLayers.forEach { $0.refreshColors() }
    }

    // MARK: - Shift state

    func updateShiftAppearance(isShifted: Bool) {
        guard !functionButtons.isEmpty else { return }
        functionButtons[0].backgroundColor = isShifted
            ? Self.glowColor.withAlphaComponent(0.3) : Self.dimColor
    }

    // MARK: - Center glow for cursor mode

    func showCenterHoldGlow() {
        let anim = CABasicAnimation(keyPath: "fillColor")
        anim.toValue = Self.glowColor.withAlphaComponent(0.15).cgColor
        anim.duration = 2.0
        anim.fillMode = .forwards
        anim.isRemovedOnCompletion = false
        centerZone.add(anim, forKey: "holdGlow")
    }

    func showCenterCursorActive() {
        centerZone.removeAnimation(forKey: "holdGlow")
        centerZone.fillColor = Self.glowColor.withAlphaComponent(0.2).cgColor
        centerZone.shadowColor = Self.glowColor.cgColor
        centerZone.shadowRadius = 12
        centerZone.shadowOpacity = 0.6
        centerZone.shadowOffset = .zero

        // Visual pulse — expand and contract to signal activation
        let pulse = CAKeyframeAnimation(keyPath: "transform.scale")
        pulse.values = [1.0, 2.5, 1.0]
        pulse.keyTimes = [0, 0.25, 1.0]
        pulse.duration = 0.4
        pulse.isRemovedOnCompletion = true
        centerZone.add(pulse, forKey: "activatePulse")

        // Haptic feedback
        let generator = UIImpactFeedbackGenerator(style: .medium)
        generator.impactOccurred()
    }

    func hideCenterGlow() {
        centerZone.removeAnimation(forKey: "holdGlow")
        centerZone.fillColor = Self.dimColor.cgColor
        centerZone.shadowOpacity = 0
        centerZone.shadowRadius = 0
    }

    // MARK: - Layer setup

    private func setupLayers() {
        for l in [innerRingArc, outerRingArc, backspaceZone, spaceZone, centerZone] {
            layer.addSublayer(l)
        }
        layer.addSublayer(backspaceLabel)
        layer.addSublayer(spaceLabel)
        layer.addSublayer(swipeTrail)
    }

    private func rebuildLayers() {
        keyCapLayers.forEach { $0.removeFromSuperlayer() }
        keyCapLayers.removeAll()

        drawRingArcs()
        drawGapZones()
        drawCenterZone()

        // Main ring keys (inner + outer)
        for slot in slots {
            let keyCap = KeyCapLayer(slot: slot)
            keyCap.updateWedge(center: center_, scale: scale)
            layer.addSublayer(keyCap)
            keyCapLayers.append(keyCap)
        }

        swipeTrail.removeFromSuperlayer()
        layer.addSublayer(swipeTrail)

        layoutArcButtons()
    }

    // MARK: - Drawing

    private func drawRingArcs() {
        let seg1Start = -RingLayoutConfig.arcStartDeg * .pi / 180.0
        let seg1End = -RingLayoutConfig.arcEndDeg * .pi / 180.0
        let seg2Start = -(RingLayoutConfig.leftGapAngle + RingLayoutConfig.gapWidthDeg / 2.0) * .pi / 180.0
        let seg2End = -(360.0 - RingLayoutConfig.gapWidthDeg / 2.0) * .pi / 180.0

        for (ringLayer, radius) in [(innerRingArc, RingLayoutConfig.innerRadius),
                                     (outerRingArc, RingLayoutConfig.outerRadius)] {
            let r = radius * scale
            let path = UIBezierPath()
            path.addArc(withCenter: center_, radius: r,
                        startAngle: seg1Start, endAngle: seg1End, clockwise: false)
            path.move(to: CGPoint(x: center_.x + r * cos(seg2Start),
                                   y: center_.y + r * sin(seg2Start)))
            path.addArc(withCenter: center_, radius: r,
                        startAngle: seg2Start, endAngle: seg2End, clockwise: false)
            ringLayer.path = path.cgPath
            ringLayer.fillColor = nil
            ringLayer.strokeColor = Self.subtleStroke.cgColor
            ringLayer.lineWidth = 0.5
            ringLayer.lineDashPattern = [4, 6]
        }
    }

    private func drawGapZones() {
        drawGapWedge(layer: backspaceZone,
                     gapCenter: RingLayoutConfig.leftGapAngle,
                     fillColor: UIColor.systemRed.withAlphaComponent(0.08).cgColor)
        positionGapLabel(backspaceLabel, text: "\u{232B}",
                         gapCenter: RingLayoutConfig.leftGapAngle, fontSize: 20)

        drawGapWedge(layer: spaceZone,
                     gapCenter: RingLayoutConfig.rightGapAngle,
                     fillColor: Self.glowColor.withAlphaComponent(0.04).cgColor)
        positionGapLabel(spaceLabel, text: "[_]",
                         gapCenter: RingLayoutConfig.rightGapAngle, fontSize: 14)
    }

    private func drawGapWedge(layer wedgeLayer: CAShapeLayer,
                              gapCenter: CGFloat, fillColor: CGColor) {
        let halfGap = RingLayoutConfig.gapWidthDeg / 2.0
        let startRad = CGFloat(-(gapCenter - halfGap)) * .pi / 180.0
        let endRad = CGFloat(-(gapCenter + halfGap)) * .pi / 180.0

        let rInner = RingLayoutConfig.outerWedgeRMin * scale
        let rOuter = RingLayoutConfig.outerWedgeRMax * scale

        let path = UIBezierPath()
        path.addArc(withCenter: center_, radius: rOuter,
                    startAngle: startRad, endAngle: endRad, clockwise: false)
        path.addArc(withCenter: center_, radius: rInner,
                    startAngle: endRad, endAngle: startRad, clockwise: true)
        path.close()

        wedgeLayer.path = path.cgPath
        wedgeLayer.fillColor = fillColor
        wedgeLayer.strokeColor = Self.subtleStroke.withAlphaComponent(0.3).cgColor
        wedgeLayer.lineWidth = 0.5
    }

    private func positionGapLabel(_ textLayer: CATextLayer, text: String,
                                  gapCenter: CGFloat, fontSize: CGFloat) {
        let midRadius = (RingLayoutConfig.outerWedgeRMin + RingLayoutConfig.outerWedgeRMax) / 2.0 * scale
        let angleRad = -gapCenter * .pi / 180.0
        let cx = center_.x + midRadius * cos(angleRad)
        let cy = center_.y + midRadius * sin(angleRad)

        let size = CGSize(width: 60, height: 24)
        textLayer.frame = CGRect(x: cx - size.width / 2, y: cy - size.height / 2,
                                 width: size.width, height: size.height)
        textLayer.string = text
        textLayer.fontSize = fontSize
        textLayer.alignmentMode = .center
        textLayer.foregroundColor = Self.labelColor.cgColor
        textLayer.contentsScale = UIScreen.main.scale
    }

    private func drawCenterZone() {
        let r = Self.centerTapRadius
        let path = UIBezierPath(ovalIn: CGRect(x: center_.x - r, y: center_.y - r,
                                               width: r * 2, height: r * 2))
        centerZone.path = path.cgPath
        centerZone.fillColor = Self.dimColor.cgColor
        centerZone.strokeColor = Self.subtleStroke.cgColor
        centerZone.lineWidth = 0.5
    }

    // MARK: - Key highlighting

    func highlightKey(at index: Int) {
        guard index >= 0, index < keyCapLayers.count else { return }
        keyCapLayers[index].setHighlighted(true)
    }

    func unhighlightAllKeys() {
        keyCapLayers.forEach { $0.setHighlighted(false) }
    }

    // MARK: - Arc buttons (punctuation left, function right)

    private func setupArcButtons() {
        let punctTitles = [".", ",", "'", "?", "!"]
        for (i, title) in punctTitles.enumerated() {
            let btn = UIButton(type: .system)
            btn.setTitle(title, for: .normal)
            btn.titleLabel?.font = .systemFont(ofSize: 16, weight: .medium)
            btn.setTitleColor(.white, for: .normal)
            btn.backgroundColor = Self.dimColor
            btn.layer.cornerRadius = 8
            btn.tag = i
            btn.addTarget(self, action: #selector(punctuationArcTapped(_:)), for: .touchUpInside)
            addSubview(btn)
            punctuationButtons.append(btn)
        }

        let funcTitles = ["\u{21E7}", "123", "\u{21B5}"]   // ⇧, 123, ↵
        for (i, title) in funcTitles.enumerated() {
            let btn = UIButton(type: .system)
            btn.setTitle(title, for: .normal)
            btn.titleLabel?.font = .systemFont(ofSize: 14, weight: .medium)
            btn.setTitleColor(.white, for: .normal)
            btn.backgroundColor = Self.dimColor
            btn.layer.cornerRadius = 8
            btn.tag = i
            btn.addTarget(self, action: #selector(functionArcTapped(_:)), for: .touchUpInside)
            addSubview(btn)
            functionButtons.append(btn)
        }
    }

    private func layoutArcButtons() {
        let radius = RingLayoutConfig.buttonArcRadius * scale
        let btnSize: CGFloat = 34.0

        // Left side: 5 punctuation buttons centered at 180°, 15° spacing
        let punctAngles: [CGFloat] = [150, 165, 180, 195, 210]
        for (i, btn) in punctuationButtons.enumerated() {
            let angleRad = -punctAngles[i] * .pi / 180.0
            let cx = center_.x + radius * cos(angleRad)
            let cy = center_.y + radius * sin(angleRad)
            btn.frame = CGRect(x: cx - btnSize / 2, y: cy - btnSize / 2,
                               width: btnSize, height: btnSize)
        }

        // Right side: 3 function buttons centered at 0°, 15° spacing
        let funcAngles: [CGFloat] = [15, 0, 345]
        for (i, btn) in functionButtons.enumerated() {
            let angleRad = -funcAngles[i] * .pi / 180.0
            let cx = center_.x + radius * cos(angleRad)
            let cy = center_.y + radius * sin(angleRad)
            btn.frame = CGRect(x: cx - btnSize / 2, y: cy - btnSize / 2,
                               width: btnSize, height: btnSize)
        }
    }

    @objc private func punctuationArcTapped(_ sender: UIButton) {
        let chars: [Character] = [".", ",", "'", "?", "!"]
        guard sender.tag < chars.count else { return }
        delegate?.ringView(self, didTapPunctuation: chars[sender.tag])
    }

    @objc private func functionArcTapped(_ sender: UIButton) {
        switch sender.tag {
        case 0: delegate?.ringView(self, didTapShift: ())
        case 1: toggleSymbolMode()
        case 2: delegate?.ringView(self, didTapReturn: ())
        default: break
        }
    }

    private func toggleSymbolMode() {
        isSymbolMode.toggle()
        slots = isSymbolMode ? symbolSlots : letterSlots
        rebuildLayers()
        // Update the 123 button appearance
        guard functionButtons.count > 1 else { return }
        functionButtons[1].backgroundColor = isSymbolMode
            ? Self.glowColor.withAlphaComponent(0.3) : Self.dimColor
    }

    // MARK: - Touch handling (raw overrides — claims touches at responder chain level)

    override func touchesBegan(_ touches: Set<UITouch>, with event: UIEvent?) {
        guard let touch = touches.first else { return }
        // Skip if touch hit a UIButton subview
        if touch.view is UIButton { return }
        touchRouter.touchBegan(touch.location(in: self))
    }

    override func touchesMoved(_ touches: Set<UITouch>, with event: UIEvent?) {
        guard let touch = touches.first else { return }
        touchRouter.touchMoved(touch.location(in: self))
    }

    override func touchesEnded(_ touches: Set<UITouch>, with event: UIEvent?) {
        guard let touch = touches.first else { return }
        touchRouter.touchEnded(touch.location(in: self))
    }

    override func touchesCancelled(_ touches: Set<UITouch>, with event: UIEvent?) {
        touchRouter.touchCancelled()
    }
}


######################################################################
# KeyboardExtension/Rendering/SwipeTrailLayer.swift
######################################################################

import UIKit
import QuartzCore

/// Renders the visible swipe path as the user drags their finger.
class SwipeTrailLayer: CAShapeLayer {

    static let glowColor = UIColor(red: 1.0, green: 0.1, blue: 0.55, alpha: 1.0) // hot pink

    private var points: [CGPoint] = []

    override init() {
        super.init()
        fillColor = nil
        strokeColor = Self.glowColor.withAlphaComponent(0.8).cgColor
        lineWidth = 2.5
        lineCap = .round
        lineJoin = .round

        // LED glow
        shadowColor = Self.glowColor.cgColor
        shadowRadius = 8
        shadowOpacity = 0.9
        shadowOffset = .zero
    }

    required init?(coder: NSCoder) { fatalError() }

    override init(layer: Any) {
        super.init(layer: layer)
    }

    func beginTrail(at point: CGPoint) {
        points = [point]
        updatePath()
    }

    func addPoint(_ point: CGPoint) {
        points.append(point)
        if points.count > 200 {
            points = stride(from: 0, to: points.count, by: 2).map { points[$0] }
        }
        updatePath()
    }

    func clearTrail() {
        points = []
        path = nil
    }

    private func updatePath() {
        guard points.count >= 2 else {
            path = nil
            return
        }
        let bezier = UIBezierPath()
        bezier.move(to: points[0])
        for p in points.dropFirst() {
            bezier.addLine(to: p)
        }
        path = bezier.cgPath
    }
}

######################################################################
# KeyboardExtension/Utilities/GeometryHelpers.swift
######################################################################

import CoreGraphics

enum GeometryHelpers {

    /// Euclidean distance between two points.
    static func distance(_ a: CGPoint, _ b: CGPoint) -> CGFloat {
        let dx = a.x - b.x
        let dy = a.y - b.y
        return sqrt(dx * dx + dy * dy)
    }

    /// Distance from a point to the center (origin).
    static func distanceFromCenter(_ point: CGPoint, center: CGPoint) -> CGFloat {
        distance(point, center)
    }

    /// Find the nearest KeySlot to a given screen point. Returns (slot, distance).
    static func nearestSlot(to point: CGPoint, in slots: [KeySlot]) -> (KeySlot, CGFloat)? {
        guard !slots.isEmpty else { return nil }
        var bestSlot = slots[0]
        var bestDist = distance(point, slots[0].screenPosition)
        for slot in slots.dropFirst() {
            let d = distance(point, slot.screenPosition)
            if d < bestDist {
                bestDist = d
                bestSlot = slot
            }
        }
        return (bestSlot, bestDist)
    }

    /// Frequency-weighted nearest slot: scores by (1/dist²) * letterFrequency.
    /// Returns the best slot and the raw distance to it (for threshold checks).
    static func weightedNearestSlot(to point: CGPoint, in slots: [KeySlot],
                                     maxDist: CGFloat) -> (KeySlot, CGFloat)? {
        guard !slots.isEmpty else { return nil }
        var bestSlot: KeySlot?
        var bestScore: CGFloat = -1
        var bestRawDist: CGFloat = .greatestFiniteMagnitude

        for slot in slots {
            let d = distance(point, slot.screenPosition)
            guard d < maxDist else { continue }

            let freq = letterFrequency[slot.letter] ?? 0.001
            // Avoid division by zero; clamp minimum distance
            let clampedDist = max(d, 1.0)
            let score = freq / (clampedDist * clampedDist)

            if score > bestScore {
                bestScore = score
                bestSlot = slot
                bestRawDist = d
            }
        }

        if let slot = bestSlot {
            return (slot, bestRawDist)
        }
        return nil
    }

    /// Angle in degrees from center to point (0 = right, CCW positive).
    static func angleDeg(from center: CGPoint, to point: CGPoint) -> CGFloat {
        let dx = point.x - center.x
        let dy = point.y - center.y
        let radians = atan2(dy, dx)
        let degrees = radians * 180.0 / .pi
        return degrees < 0 ? degrees + 360.0 : degrees
    }

    /// Check if an angle (degrees) falls within a gap.
    static func angleInGap(_ angleDeg: CGFloat,
                           gapCenter: CGFloat,
                           gapWidth: CGFloat) -> Bool {
        let half = gapWidth / 2.0
        let start = fmod(gapCenter - half + 360.0, 360.0)
        let end = fmod(gapCenter + half, 360.0)
        if start < end {
            return angleDeg >= start && angleDeg < end
        } else {
            return angleDeg >= start || angleDeg < end
        }
    }

    // MARK: - English letter frequencies (relative, sums to ~1.0)

    static let letterFrequency: [Character: CGFloat] = [
        "E": 0.127, "T": 0.091, "A": 0.082, "O": 0.075, "I": 0.070,
        "N": 0.067, "S": 0.063, "H": 0.061, "R": 0.060, "D": 0.043,
        "L": 0.040, "C": 0.028, "U": 0.028, "M": 0.024, "W": 0.024,
        "F": 0.022, "G": 0.020, "Y": 0.020, "P": 0.019, "B": 0.015,
        "V": 0.010, "K": 0.008, "J": 0.002, "X": 0.002, "Q": 0.001,
        "Z": 0.001,
    ]
}

######################################################################
# BetterKeyboardApp/AppDelegate.swift
######################################################################

import UIKit

@main
class AppDelegate: UIResponder, UIApplicationDelegate {
    var window: UIWindow?

    func application(
        _ application: UIApplication,
        didFinishLaunchingWithOptions launchOptions: [UIApplication.LaunchOptionsKey: Any]?
    ) -> Bool {
        window = UIWindow(frame: UIScreen.main.bounds)
        window?.rootViewController = MainViewController()
        window?.makeKeyAndVisible()
        return true
    }
}

######################################################################
# BetterKeyboardApp/MainViewController.swift
######################################################################

import UIKit

class MainViewController: UIViewController {

    private let titleLabel = UILabel()
    private let instructionsLabel = UILabel()
    private let stepsLabel = UILabel()

    override func viewDidLoad() {
        super.viewDidLoad()
        view.backgroundColor = .systemBackground
        setupUI()
    }

    private func setupUI() {
        titleLabel.text = "Better Keyboard"
        titleLabel.font = .systemFont(ofSize: 32, weight: .bold)
        titleLabel.textAlignment = .center
        titleLabel.translatesAutoresizingMaskIntoConstraints = false

        instructionsLabel.text = "To enable the circular keyboard:"
        instructionsLabel.font = .systemFont(ofSize: 18, weight: .medium)
        instructionsLabel.textAlignment = .center
        instructionsLabel.translatesAutoresizingMaskIntoConstraints = false

        let steps = """
        1. Open Settings
        2. Go to General → Keyboard → Keyboards
        3. Tap "Add New Keyboard..."
        4. Select "Better Keyboard"
        5. Switch to it in any text field using the globe key
        """
        stepsLabel.text = steps
        stepsLabel.font = .systemFont(ofSize: 16)
        stepsLabel.numberOfLines = 0
        stepsLabel.textColor = .secondaryLabel
        stepsLabel.translatesAutoresizingMaskIntoConstraints = false

        view.addSubview(titleLabel)
        view.addSubview(instructionsLabel)
        view.addSubview(stepsLabel)

        NSLayoutConstraint.activate([
            titleLabel.centerXAnchor.constraint(equalTo: view.centerXAnchor),
            titleLabel.topAnchor.constraint(equalTo: view.safeAreaLayoutGuide.topAnchor, constant: 60),

            instructionsLabel.centerXAnchor.constraint(equalTo: view.centerXAnchor),
            instructionsLabel.topAnchor.constraint(equalTo: titleLabel.bottomAnchor, constant: 40),

            stepsLabel.leadingAnchor.constraint(equalTo: view.leadingAnchor, constant: 40),
            stepsLabel.trailingAnchor.constraint(equalTo: view.trailingAnchor, constant: -40),
            stepsLabel.topAnchor.constraint(equalTo: instructionsLabel.bottomAnchor, constant: 20),
        ])
    }
}
